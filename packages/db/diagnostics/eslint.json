[{"filePath":"/Users/azaatar/bowdoin-marketplace/packages/db/scripts/backfill-affiliation.mts","messages":[{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'no-console').","line":135,"column":3,"severity":1,"nodeType":null,"fix":{"range":[3767,3805],"text":" "}},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":136,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":136,"endColumn":10},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'no-console').","line":145,"column":5,"severity":1,"nodeType":null,"fix":{"range":[4139,4177],"text":" "}},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":146,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":146,"endColumn":12},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'no-console').","line":156,"column":9,"severity":1,"nodeType":null,"fix":{"range":[4482,4520],"text":" "}},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":157,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":157,"endColumn":16},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'no-console').","line":173,"column":7,"severity":1,"nodeType":null,"fix":{"range":[4889,4927],"text":" "}},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":174,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":174,"endColumn":14},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'no-console').","line":187,"column":3,"severity":1,"nodeType":null,"fix":{"range":[5304,5342],"text":" "}},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":188,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":188,"endColumn":10},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'no-console').","line":196,"column":7,"severity":1,"nodeType":null,"fix":{"range":[5580,5618],"text":" "}},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":197,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":197,"endColumn":14}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":6,"source":"// packages/db/scripts/backfill-affiliation.mts\n/**\n * Backfill user.affiliation based on email domain (Bowdoin vs Community).\n *\n * Rules:\n *  - Emails ending in \"@bowdoin.edu\" => Affiliation.bowdoin_member\n *  - Everything else => Affiliation.community\n *\n * Safety:\n *  - Defaults to DRY-RUN (no writes) unless --apply (or APPLY=1) is set.\n *  - By default, only users with NULL/UNKNOWN affiliation are targeted.\n *    Use --all to re-evaluate all users.\n *  - Optional --limit N to cap updates.\n *\n * Usage:\n *  pnpm -w ts-node packages/db/scripts/backfill-affiliation.mts --apply --limit 500\n *  APPLY=1 pnpm -w ts-node packages/db/scripts/backfill-affiliation.mts --all\n */\n\nimport { PrismaClient, Affiliation } from '@prisma/client';\nimport process from 'node:process';\nimport { setTimeout as delay } from 'node:timers/promises';\n\ntype CliOpts = {\n  apply: boolean;\n  all: boolean;\n  limit?: number;\n  batchSize: number;\n  sleepMs: number;\n};\n\nconst prisma = new PrismaClient();\n\nfunction parseArgs(argv: string[]): CliOpts {\n  const opts: CliOpts = {\n    apply: process.env.APPLY === '1' || argv.includes('--apply'),\n    all: argv.includes('--all'),\n    limit: undefined,\n    batchSize: 200,\n    sleepMs: 25,\n  };\n\n  const limitIx = argv.findIndex((a) => a === '--limit');\n  if (limitIx !== -1 && argv[limitIx + 1]) {\n    const n = Number(argv[limitIx + 1]);\n    if (!Number.isNaN(n) && n > 0) opts.limit = n;\n  }\n\n  const bsIx = argv.findIndex((a) => a === '--batch');\n  if (bsIx !== -1 && argv[bsIx + 1]) {\n    const n = Number(argv[bsIx + 1]);\n    if (!Number.isNaN(n) && n > 0) opts.batchSize = n;\n  }\n\n  const sleepIx = argv.findIndex((a) => a === '--sleep');\n  if (sleepIx !== -1 && argv[sleepIx + 1]) {\n    const n = Number(argv[sleepIx + 1]);\n    if (!Number.isNaN(n) && n >= 0) opts.sleepMs = n;\n  }\n\n  return opts;\n}\n\nfunction inferAffiliation(email: string): Affiliation {\n  const domain = email.split('@')[1]?.toLowerCase().trim();\n  if (!domain) return Affiliation.unknown;\n  if (domain === 'bowdoin.edu') return Affiliation.bowdoin_member;\n  return Affiliation.community;\n}\n\nfunction chunk<T>(arr: T[], size: number): T[][] {\n  const out: T[][] = [];\n  for (let i = 0; i < arr.length; i += size) out.push(arr.slice(i, i + size));\n  return out;\n}\n\nasync function selectTargets(opts: CliOpts) {\n  if (opts.all) {\n    return prisma.user.findMany({\n      select: { id: true, email: true, affiliation: true },\n      where: { email: { not: null } },\n      orderBy: { createdAt: 'asc' },\n      take: opts.limit,\n    });\n  }\n\n  return prisma.user.findMany({\n    select: { id: true, email: true, affiliation: true },\n    where: {\n      email: { not: null },\n      OR: [{ affiliation: null }, { affiliation: Affiliation.unknown }],\n    },\n    orderBy: { createdAt: 'asc' },\n    take: opts.limit,\n  });\n}\n\nasync function writeAffiliation(\n  userId: string,\n  newAff: Affiliation,\n  oldAff: Affiliation | null,\n  email: string,\n  apply: boolean,\n) {\n  if (!apply) return;\n\n  // Use a transaction so audit log + user update are atomic.\n  await prisma.$transaction(async (tx) => {\n    await tx.user.update({\n      where: { id: userId },\n      data: { affiliation: newAff, updatedAt: new Date() },\n    });\n\n    // Record an audit log row if table/model exists.\n    // We assume an AuditLog model with fields: id, type, userId, data(Json), createdAt.\n    await tx.auditLog.create({\n      data: {\n        type: 'affiliation.backfill',\n        userId: userId,\n        data: {\n          from: oldAff ?? 'null',\n          to: newAff,\n          reason: 'domain_inference',\n          email,\n        } as unknown as any,\n      },\n    });\n  });\n}\n\nasync function main() {\n  const opts = parseArgs(process.argv.slice(2));\n  const targets = await selectTargets(opts);\n\n  // eslint-disable-next-line no-console\n  console.log(\n    `[affiliation/backfill] candidates=${targets.length} apply=${opts.apply} all=${opts.all} limit=${opts.limit ?? '∞'} batch=${opts.batchSize} sleep=${opts.sleepMs}ms`,\n  );\n\n  let updated = 0;\n  let skipped = 0;\n\n  const batches = chunk(targets, opts.batchSize);\n  for (const [bi, batch] of batches.entries()) {\n    // eslint-disable-next-line no-console\n    console.log(\n      `[affiliation/backfill] processing batch ${bi + 1}/${batches.length} size=${batch.length}`,\n    );\n\n    for (const u of batch) {\n      const email = u.email!;\n      const inferred = inferAffiliation(email);\n\n      if (inferred === Affiliation.unknown) {\n        skipped++;\n        // eslint-disable-next-line no-console\n        console.warn(\n          `[affiliation/backfill] skip user=${u.id} email=${email} -> inferred=unknown`,\n        );\n        continue;\n      }\n\n      if (!opts.all && u.affiliation && u.affiliation !== Affiliation.unknown) {\n        skipped++;\n        continue;\n      }\n\n      if (u.affiliation === inferred) {\n        skipped++;\n        continue;\n      }\n\n      // eslint-disable-next-line no-console\n      console.log(\n        `[affiliation/backfill] user=${u.id} email=${email} from=${u.affiliation ?? 'null'} -> ${inferred}${opts.apply ? '' : ' (dry-run)'}`,\n      );\n\n      await writeAffiliation(u.id, inferred, u.affiliation, email, opts.apply);\n      updated++;\n    }\n\n    if (opts.sleepMs > 0 && bi < batches.length - 1) {\n      await delay(opts.sleepMs);\n    }\n  }\n\n  // eslint-disable-next-line no-console\n  console.log(\n    `[affiliation/backfill] done candidates=${targets.length} updated=${updated} skipped=${skipped} apply=${opts.apply}`,\n  );\n}\n\nif (import.meta.url === `file://${process.argv[1]}`) {\n  main()\n    .catch((err) => {\n      // eslint-disable-next-line no-console\n      console.error('[affiliation/backfill] ERROR', err);\n      process.exitCode = 1;\n    })\n    .finally(async () => {\n      await prisma.$disconnect();\n    });\n}","usedDeprecatedRules":[]},{"filePath":"/Users/azaatar/bowdoin-marketplace/packages/db/seed/community.seed.ts","messages":[{"ruleId":"import/order","severity":2,"message":"`@bowdoin/observability/logger` import should occur before import of `@prisma/client`","line":19,"column":1,"nodeType":"ImportDeclaration","endLine":19,"endColumn":60,"fix":{"range":[653,794],"text":"import { logger } from '@bowdoin/observability/logger';\nimport { PrismaClient, Affiliation, Role, ListingStatus } from '@prisma/client';\n"}},{"ruleId":"import/no-unresolved","severity":2,"message":"Unable to resolve path to module '@bowdoin/observability/logger'.","line":19,"column":24,"nodeType":"Literal","endLine":19,"endColumn":59},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":283,"column":35,"nodeType":"Identifier","messageId":"undef","endLine":283,"endColumn":42},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":285,"column":17,"nodeType":"Identifier","messageId":"undef","endLine":285,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":285,"column":52,"nodeType":"Identifier","messageId":"undef","endLine":285,"endColumn":59},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":286,"column":23,"nodeType":"Identifier","messageId":"undef","endLine":286,"endColumn":30},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'no-console').","line":293,"column":7,"severity":1,"nodeType":null,"fix":{"range":[9328,9366],"text":" "}},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":294,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":294,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":295,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":295,"endColumn":14},{"ruleId":"@typescript-eslint/no-misused-promises","severity":2,"message":"Promise returned in function argument where a void return was expected.","line":297,"column":14,"nodeType":"ArrowFunctionExpression","messageId":"voidReturnArgument","endLine":299,"endColumn":6}],"suppressedMessages":[],"errorCount":9,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":1,"fixableWarningCount":1,"source":"// packages/db/seed/community.seed.ts\n/**\n * Community (Brunswick) population seed\n *\n * Purpose:\n *  - Populate a realistic set of community (non-Bowdoin) users.\n *  - Create a handful of public listings visible to Bowdoin + Community.\n *  - (Optionally) create basic message threads across the Bowdoin/community boundary\n *    to exercise authorization checks.\n *\n * Design:\n *  - Idempotent upserts keyed by email and deterministic IDs where helpful.\n *  - Never runs automatically in production.\n *  - Exported `runCommunitySeed` so the main seed can call it, plus a CLI entry\n *    for local ad-hoc execution: `pnpm -w run db:seed:community`.\n */\n\nimport { PrismaClient, Affiliation, Role, ListingStatus } from '@prisma/client';\nimport { logger } from '@bowdoin/observability/logger';\n\ntype Options = {\n  /**\n   * When true, also create cross-affiliation threads/messages to verify policy.\n   */\n  createCrossAffiliationThreads?: boolean;\n  /**\n   * When provided, an existing Bowdoin member email will be used as the\n   * \"buyer\" in cross-affiliation threads; if not found, threads are skipped.\n   */\n  bowdoinBuyerEmail?: string;\n};\n\nexport async function runCommunitySeed(prisma: PrismaClient, opts: Options = {}) {\n  const now = new Date();\n\n  logger.info({ msg: 'Community seed: starting…', opts });\n\n  // Ensure audience tags exist (in case this runs standalone)\n  const [tagCommunity] = await Promise.all([\n    prisma.audienceTag.upsert({\n      where: { key: 'community_allowed' },\n      update: { name: 'Bowdoin + Community' },\n      create: { key: 'community_allowed', name: 'Bowdoin + Community' },\n    }),\n  ]);\n\n  // A small, realistic set of community accounts\n  const communityAccounts = [\n    {\n      id: '10000000-0000-0000-0000-000000000101',\n      name: 'Alex Johnson',\n      email: 'alex.johnson@brunswickmail.org',\n      verifiedAt: now,\n    },\n    {\n      id: '10000000-0000-0000-0000-000000000102',\n      name: 'Casey Lee',\n      email: 'casey.lee@maine.local',\n      verifiedAt: now,\n    },\n    {\n      id: '10000000-0000-0000-0000-000000000103',\n      name: 'Jordan Kim',\n      email: 'jordan.kim@brunswick.community',\n      verifiedAt: null, // not yet community-verified\n    },\n    {\n      id: '10000000-0000-0000-0000-000000000104',\n      name: 'Taylor Smith',\n      email: 'taylor.smith@neighborhood.net',\n      verifiedAt: now,\n    },\n  ] as const;\n\n  const users = await Promise.all(\n    communityAccounts.map((u) =>\n      prisma.user.upsert({\n        where: { email: u.email },\n        update: {\n          name: u.name,\n          affiliation: Affiliation.community,\n          role: Role.student,\n          // keep existing emailVerified if already set\n          communityEmailVerified: u.verifiedAt ?? undefined,\n        },\n        create: {\n          id: u.id,\n          email: u.email,\n          name: u.name,\n          role: Role.student,\n          affiliation: Affiliation.community,\n          emailVerified: now, // account verified as an app user\n          communityEmailVerified: u.verifiedAt,\n        },\n      }),\n    ),\n  );\n\n  logger.info({\n    msg: 'Community seed: users upserted',\n    count: users.length,\n    verified: users.filter((u) => u.communityEmailVerified).length,\n  });\n\n  // Listings authored by community members, visible to Bowdoin + Community\n  const listingSpecs = [\n    {\n      id: '20000000-0000-0000-0000-000000000201',\n      ownerEmail: 'alex.johnson@brunswickmail.org',\n      title: 'Bike — commuter, medium frame',\n      description:\n        'Gently used commuter bike, includes lights and a bell. Pickup in Brunswick; can meet near campus.',\n      price: 75,\n      isFree: false,\n      condition: 'good',\n      category: 'Bikes',\n      location: 'Brunswick – Maine Street',\n    },\n    {\n      id: '20000000-0000-0000-0000-000000000202',\n      ownerEmail: 'casey.lee@maine.local',\n      title: 'Bookshelf (Free)',\n      description:\n        'Sturdy IKEA bookshelf (white). Some wear on edges. First-come, first-served. I can help load.',\n      price: 0,\n      isFree: true,\n      condition: 'fair',\n      category: 'Furniture',\n      location: 'Brunswick – near Bowdoin campus',\n    },\n    {\n      id: '20000000-0000-0000-0000-000000000203',\n      ownerEmail: 'taylor.smith@neighborhood.net',\n      title: 'Kitchen set: pots & pans',\n      description:\n        'Assorted pots and pans, non-stick. Perfect for a student kitchen setup. Bundle price.',\n      price: 20,\n      isFree: false,\n      condition: 'good',\n      category: 'Kitchen',\n      location: 'Brunswick – Pleasant St.',\n    },\n  ] as const;\n\n  // Map owners\n  const byEmail = new Map(users.map((u) => [u.email, u]));\n  const listings = await Promise.all(\n    listingSpecs.map((l) => {\n      const owner = byEmail.get(l.ownerEmail);\n      if (!owner) {\n        throw new Error(`Owner not found for seed listing: ${l.ownerEmail}`);\n      }\n      return prisma.listing.upsert({\n        where: { id: l.id },\n        update: {\n          title: l.title,\n          description: l.description,\n          price: l.price,\n          isFree: l.isFree,\n          condition: l.condition,\n          category: l.category,\n          location: l.location,\n          status: ListingStatus.active,\n          audienceTagId: tagCommunity.id,\n        },\n        create: {\n          id: l.id,\n          userId: owner.id,\n          title: l.title,\n          description: l.description,\n          price: l.price,\n          isFree: l.isFree,\n          condition: l.condition,\n          category: l.category,\n          location: l.location,\n          availableStart: now,\n          availableEnd: null,\n          status: ListingStatus.active,\n          audienceTagId: tagCommunity.id,\n          createdAt: now,\n          updatedAt: now,\n        },\n      });\n    }),\n  );\n\n  logger.info({\n    msg: 'Community seed: listings upserted',\n    count: listings.length,\n    ids: listings.map((l) => l.id),\n  });\n\n  // Optional: create a thread between a Bowdoin buyer and a community seller for the first listing\n  if (opts.createCrossAffiliationThreads && opts.bowdoinBuyerEmail) {\n    const bowdoinBuyer = await prisma.user.findUnique({\n      where: { email: opts.bowdoinBuyerEmail },\n      select: { id: true, affiliation: true, email: true },\n    });\n\n    if (!bowdoinBuyer) {\n      logger.warn({\n        msg: 'Community seed: bowdoinBuyerEmail not found; skipping cross-affiliation thread.',\n        bowdoinBuyerEmail: opts.bowdoinBuyerEmail,\n      });\n    } else if (bowdoinBuyer.affiliation !== Affiliation.bowdoin_member) {\n      logger.warn({\n        msg: 'Community seed: provided bowdoinBuyerEmail is not a Bowdoin member; skipping thread.',\n        bowdoinBuyerEmail: bowdoinBuyer.email,\n      });\n    } else {\n      const targetListing = listings[0];\n      const seller = await prisma.user.findUniqueOrThrow({\n        where: { id: targetListing.userId },\n        select: { id: true, email: true },\n      });\n\n      const thread = await prisma.thread.upsert({\n        where: {\n          listingId_buyerId: { listingId: targetListing.id, buyerId: bowdoinBuyer.id },\n        },\n        update: {},\n        create: {\n          id: '30000000-0000-0000-0000-000000000301',\n          listingId: targetListing.id,\n          sellerId: seller.id,\n          buyerId: bowdoinBuyer.id,\n          createdAt: now,\n        },\n      });\n\n      await prisma.message.upsert({\n        where: { id: '30000000-0000-0000-0000-0000000003a1' },\n        update: {\n          body: 'Hi! Interested in the commuter bike. Is it still available?',\n          sentAt: now,\n          senderId: bowdoinBuyer.id,\n          threadId: thread.id,\n        },\n        create: {\n          id: '30000000-0000-0000-0000-0000000003a1',\n          body: 'Hi! Interested in the commuter bike. Is it still available?',\n          sentAt: now,\n          senderId: bowdoinBuyer.id,\n          threadId: thread.id,\n        },\n      });\n\n      await prisma.message.upsert({\n        where: { id: '30000000-0000-0000-0000-0000000003a2' },\n        update: {\n          body: 'Yes! I can meet near campus later today.',\n          sentAt: new Date(now.getTime() + 90_000),\n          senderId: seller.id,\n          threadId: thread.id,\n        },\n        create: {\n          id: '30000000-0000-0000-0000-0000000003a2',\n          body: 'Yes! I can meet near campus later today.',\n          sentAt: new Date(now.getTime() + 90_000),\n          senderId: seller.id,\n          threadId: thread.id,\n        },\n      });\n\n      logger.info({\n        msg: 'Community seed: cross-affiliation thread created',\n        threadId: thread.id,\n        listingId: targetListing.id,\n        buyer: bowdoinBuyer.email,\n        seller: seller.email,\n      });\n    }\n  }\n\n  logger.info({ msg: 'Community seed: complete.' });\n}\n\n/**\n * Allow running this seed directly:\n *   pnpm -w ts-node packages/db/seed/community.seed.ts\n * or via package script `db:seed:community`.\n */\nif (import.meta.url === `file://${process.argv[1]}`) {\n  const prisma = new PrismaClient();\n  const buyer = process.env.BOWDOIN_BUYER_EMAIL || process.env.BOWDOIN_STUDENT_EMAIL; // tolerate a common typo\n  const withThreads = process.env.CREATE_CROSS_AFFILIATION_THREADS === '1';\n\n  runCommunitySeed(prisma, {\n    createCrossAffiliationThreads: withThreads,\n    bowdoinBuyerEmail: buyer,\n  })\n    .catch((err) => {\n      // eslint-disable-next-line no-console\n      console.error(err);\n      process.exitCode = 1;\n    })\n    .finally(async () => {\n      await prisma.$disconnect();\n    });\n}","usedDeprecatedRules":[]},{"filePath":"/Users/azaatar/bowdoin-marketplace/packages/db/src/index.ts","messages":[{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'no-console').","line":1,"column":1,"severity":1,"nodeType":null,"fix":{"range":[0,31],"text":" "}},{"ruleId":"@typescript-eslint/consistent-type-imports","severity":2,"message":"Imports \"Prisma\" are only used as type.","line":2,"column":1,"nodeType":"ImportDeclaration","messageId":"someImportsAreOnlyTypes","endLine":2,"endColumn":55,"fix":{"range":[32,61],"text":"import type { Prisma } from '@prisma/client';\nimport { PrismaClient"}},{"ruleId":"import/order","severity":2,"message":"`@prisma/client` import should occur after import of `@bowdoin/observability/tracing`","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":55,"fix":{"range":[32,258],"text":"import { env } from '@bowdoin/config/env';\nimport { logger } from '@bowdoin/observability/logger';\nimport { getTracer } from '@bowdoin/observability/tracing';\nimport { PrismaClient, Prisma } from '@prisma/client';\n"}},{"ruleId":"import/no-unresolved","severity":2,"message":"Unable to resolve path to module '@bowdoin/config/env'.","line":3,"column":21,"nodeType":"Literal","endLine":3,"endColumn":46},{"ruleId":"import/no-unresolved","severity":2,"message":"Unable to resolve path to module '@bowdoin/observability/logger'.","line":4,"column":24,"nodeType":"Literal","endLine":4,"endColumn":59},{"ruleId":"import/no-unresolved","severity":2,"message":"Unable to resolve path to module '@bowdoin/observability/tracing'.","line":5,"column":27,"nodeType":"Literal","endLine":5,"endColumn":63},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'no-var').","line":28,"column":3,"severity":1,"nodeType":null,"fix":{"range":[949,983],"text":" "}},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async arrow function has no 'await' expression.","line":74,"column":36,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":74,"endColumn":38,"suggestions":[{"messageId":"removeAsync","fix":{"range":[2351,2357],"text":""},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async function 'withTransaction' has no 'await' expression.","line":147,"column":8,"nodeType":"FunctionDeclaration","messageId":"missingAwait","endLine":147,"endColumn":41,"suggestions":[{"messageId":"removeAsync","fix":{"range":[4281,4438],"text":"function withTransaction<T>(\n  fn: (tx: Prisma.TransactionClient) => Promise<T>,\n  options?: Parameters<PrismaClient['$transaction']>[1],\n): T"},"desc":"Remove 'async'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'tx' is defined but never used.","line":148,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":148,"endColumn":36,"suggestions":[{"messageId":"removeVar","data":{"varName":"tx"},"fix":{"range":[4323,4351],"text":""},"desc":"Remove unused variable 'tx'."}]}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":2,"fixableWarningCount":2,"source":"/* eslint-disable no-console */\nimport { PrismaClient, Prisma } from '@prisma/client';\nimport { env } from '@bowdoin/config/env';\nimport { logger } from '@bowdoin/observability/logger';\nimport { getTracer } from '@bowdoin/observability/tracing';\n\nconst isProd = env.NODE_ENV === 'production';\nconst isTest = env.NODE_ENV === 'test';\n\n/**\n * Prisma logging: in dev, surface query timing to console for quick diagnosis.\n * In prod, keep it lean; rely on OpenTelemetry spans + error logs.\n */\nconst prismaLog: Prisma.LogDefinition[] = isProd\n  ? [{ level: 'error', emit: 'event' }, { level: 'warn', emit: 'event' }]\n  : [\n      { level: 'query', emit: 'event' },\n      { level: 'info', emit: 'event' },\n      { level: 'warn', emit: 'event' },\n      { level: 'error', emit: 'event' },\n    ];\n\n/**\n * Singleton PrismaClient across hot-reloads:\n *  - Node.js re-creates module state on dev reloads; stash on globalThis.\n */\ndeclare global {\n  // eslint-disable-next-line no-var\n  var __PRISMA__: PrismaClient | undefined;\n}\n\nfunction createPrisma(): PrismaClient {\n  const client = new PrismaClient({\n    log: prismaLog,\n    errorFormat: isProd ? 'minimal' : 'colorless',\n    datasources: env.DATABASE_URL ? { db: { url: env.DATABASE_URL } } : undefined,\n  });\n\n  // Bridge Prisma event logs -> pino\n  prismaLog.forEach((def) => {\n    if (def.emit !== 'event') return;\n\n    client.$on(def.level as Prisma.LogLevel, (e) => {\n      switch (def.level) {\n        case 'query': {\n          // Keep dev-only noisy logs out of prod\n          if (!isProd) {\n            // @ts-expect-error known Prisma event shape\n            const { query, params, duration, target } = e;\n            logger.debug(\n              { query, params, duration, target, component: 'prisma' },\n              'prisma.query',\n            );\n          }\n          break;\n        }\n        case 'info':\n          logger.info({ component: 'prisma', ...e }, 'prisma.info');\n          break;\n        case 'warn':\n          logger.warn({ component: 'prisma', ...e }, 'prisma.warn');\n          break;\n        case 'error':\n          logger.error({ component: 'prisma', ...e }, 'prisma.error');\n          break;\n        default:\n          break;\n      }\n    });\n  });\n\n  // Optional: tie Prisma queries into OTEL spans (lightweight tagging)\n  const tracer = getTracer();\n  client.$use(async (params, next) => {\n    return tracer.startActiveSpan(`prisma.${params.model ?? 'raw'}.${params.action}`, async (span) => {\n      try {\n        // Annotate common attributes\n        if (params.model) span.setAttribute('db.sql.table', params.model);\n        span.setAttribute('db.operation', params.action);\n        const result = await next(params);\n        return result;\n      } catch (err) {\n        span.recordException(err as Error);\n        span.setStatus({ code: 2 }); // ERROR\n        throw err;\n      } finally {\n        span.end();\n      }\n    });\n  });\n\n  return client;\n}\n\n// Reuse singleton in dev; fresh in prod/test per process\nexport const prisma: PrismaClient =\n  globalThis.__PRISMA__ ?? createPrisma();\n\nif (!isProd && !isTest) {\n  globalThis.__PRISMA__ = prisma;\n}\n\n/**\n * Connect lazily; callers can await to ensure a live pool.\n */\nexport async function connectIfNeeded(): Promise<void> {\n  // Prisma defers connection until first query; explicit connect aids readyz\n  try {\n    await prisma.$connect();\n  } catch (err) {\n    logger.error({ err }, 'db.connect.failed');\n    throw err;\n  }\n}\n\n/**\n * Health probe for /api/healthz and /api/readyz:\n * - round-trips with NOW() and version()\n */\nexport async function dbHealthCheck(): Promise<{\n  ok: boolean;\n  now?: string;\n  version?: string;\n  error?: string;\n}> {\n  try {\n    // Minimal, cheap roundtrip\n    const [{ now }] = await prisma.$queryRawUnsafe<Array<{ now: string }>>(\n      'SELECT NOW()::text as now;',\n    );\n    const [{ version }] = await prisma.$queryRawUnsafe<Array<{ version: string }>>(\n      'SELECT version();',\n    );\n\n    return { ok: true, now, version };\n  } catch (err) {\n    logger.error({ err }, 'db.health.failed');\n    return { ok: false, error: (err as Error).message };\n  }\n}\n\n/**\n * Transaction helper with correct typing.\n * Usage:\n *   await withTransaction(async (tx) => { await tx.user.create(...); })\n */\nexport async function withTransaction<T>(\n  fn: (tx: Prisma.TransactionClient) => Promise<T>,\n  options?: Parameters<PrismaClient['$transaction']>[1],\n): Promise<T> {\n  return prisma.$transaction(async (tx) => fn(tx), options);\n}\n\n/**\n * Graceful shutdown; call from process signal handlers in the web/worker.\n */\nexport async function shutdownPrisma(): Promise<void> {\n  try {\n    await prisma.$disconnect();\n  } catch (err) {\n    logger.warn({ err }, 'db.disconnect.warn');\n  }\n}\n\n// Convenience re-exports for consumers that want types\nexport type { PrismaClient } from '@prisma/client';\nexport type { Prisma as PrismaTypes } from '@prisma/client';","usedDeprecatedRules":[]},{"filePath":"/Users/azaatar/bowdoin-marketplace/packages/db/src/migrate.ts","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'pathToFileURL' is defined but never used.","line":21,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":21,"endColumn":38,"suggestions":[{"messageId":"removeVar","data":{"varName":"pathToFileURL"},"fix":{"range":[869,884],"text":""},"desc":"Remove unused variable 'pathToFileURL'."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'pathToFileURL' is defined but never used. Allowed unused vars must match /^_/u.","line":21,"column":25,"nodeType":null,"messageId":"unusedVar","endLine":21,"endColumn":38},{"ruleId":"import/order","severity":2,"message":"`node:path` import should occur before import of `node:url`","line":22,"column":1,"nodeType":"ImportDeclaration","endLine":22,"endColumn":46,"fix":{"range":[847,950],"text":"import { dirname, resolve } from 'node:path';\nimport { fileURLToPath, pathToFileURL } from 'node:url';\n"}},{"ruleId":"import/no-unresolved","severity":2,"message":"Unable to resolve path to module '@bowdoin/config/env'.","line":24,"column":21,"nodeType":"Literal","endLine":24,"endColumn":46},{"ruleId":"import/no-unresolved","severity":2,"message":"Unable to resolve path to module '@bowdoin/observability/logger'.","line":25,"column":24,"nodeType":"Literal","endLine":25,"endColumn":59},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":37,"column":15,"nodeType":"Identifier","messageId":"undef","endLine":37,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":44,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":44,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":45,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":45,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":53,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":53,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":54,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":54,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":61,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":61,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":67,"column":14,"nodeType":"Identifier","messageId":"undef","endLine":67,"endColumn":21},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":81,"column":24,"nodeType":"Identifier","messageId":"undef","endLine":81,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":90,"column":23,"nodeType":"Identifier","messageId":"undef","endLine":90,"endColumn":30},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":98,"column":23,"nodeType":"Identifier","messageId":"undef","endLine":98,"endColumn":30},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":105,"column":23,"nodeType":"Identifier","messageId":"undef","endLine":105,"endColumn":30},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":118,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":118,"endColumn":18},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":120,"column":23,"nodeType":"Identifier","messageId":"undef","endLine":120,"endColumn":30},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":132,"column":23,"nodeType":"Identifier","messageId":"undef","endLine":132,"endColumn":30},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":142,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":142,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":143,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":143,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":150,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":150,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":151,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":151,"endColumn":10}],"suppressedMessages":[],"errorCount":23,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"// packages/db/src/migrate.ts\n/**\n * Bowdoin Marketplace — Prisma migration runner\n *\n * Safe, production-minded wrapper over Prisma CLI for:\n *  - deploy:  prisma migrate deploy     (production-safe)\n *  - status:  prisma migrate status     (introspection only)\n *  - generate:prisma generate           (generate client)\n *  - reset:   prisma migrate reset      (DEV ONLY unless FORCE=1)\n *  - push:    prisma db push            (DEV ONLY unless FORCE=1)\n *\n * Usage:\n *   pnpm --filter @bowdoin/db exec ts-node src/migrate.ts deploy\n *   pnpm --filter @bowdoin/db exec ts-node src/migrate.ts status\n *   pnpm --filter @bowdoin/db exec ts-node src/migrate.ts generate\n *   pnpm --filter @bowdoin/db exec ts-node src/migrate.ts reset\n *   pnpm --filter @bowdoin/db exec ts-node src/migrate.ts push\n */\n\nimport { spawn } from 'node:child_process';\nimport { fileURLToPath, pathToFileURL } from 'node:url';\nimport { dirname, resolve } from 'node:path';\n\nimport { env } from '@bowdoin/config/env';\nimport { logger } from '@bowdoin/observability/logger';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = dirname(__filename);\n\n// Ensure we run prisma relative to this package so it picks up prisma/schema.prisma\nconst DB_PKG_DIR = resolve(__dirname, '..');\nconst PRISMA_SCHEMA = resolve(DB_PKG_DIR, 'prisma', 'schema.prisma');\n\ntype Command = 'deploy' | 'status' | 'generate' | 'reset' | 'push';\n\nconst isProd = env.NODE_ENV === 'production';\nconst FORCE = process.env.FORCE === '1';\n\nfunction ensureDatabaseUrl() {\n  if (!env.DATABASE_URL) {\n    const msg =\n      'DATABASE_URL is not set. Aborting. Provide a valid Postgres connection string in env.';\n    logger.error({ msg });\n    process.stderr.write(`${msg}\\n`);\n    process.exit(2);\n  }\n}\n\nfunction forbidInProdUnlessForced(cmd: Command) {\n  if (isProd && (cmd === 'reset' || cmd === 'push') && !FORCE) {\n    const msg = `Refusing to run '${cmd}' in production. Set FORCE=1 if you really intend to do this.`;\n    logger.error({ msg, cmd, isProd, FORCE });\n    process.stderr.write(`${msg}\\n`);\n    process.exit(3);\n  }\n}\n\nfunction runPrisma(args: string[]): Promise<number> {\n  return new Promise((resolveExit) => {\n    const child = spawn(\n      process.platform === 'win32' ? 'npx.cmd' : 'npx',\n      ['-y', 'prisma', ...args, '--schema', PRISMA_SCHEMA],\n      {\n        cwd: DB_PKG_DIR,\n        stdio: 'inherit',\n        env: {\n          ...process.env,\n          DATABASE_URL: env.DATABASE_URL,\n          NODE_ENV: env.NODE_ENV,\n        },\n      },\n    );\n\n    child.on('close', (code) => {\n      resolveExit(code ?? 1);\n    });\n  });\n}\n\nasync function main() {\n  const [, , rawCmd] = process.argv;\n  const cmd = (rawCmd as Command) || 'status';\n\n  ensureDatabaseUrl();\n\n  switch (cmd) {\n    case 'deploy': {\n      logger.info({ msg: 'Applying pending migrations (prisma migrate deploy)…', schema: PRISMA_SCHEMA });\n      const code = await runPrisma(['migrate', 'deploy']);\n      if (code !== 0) process.exit(code);\n      logger.info({ msg: 'Migrations deployed successfully.' });\n      break;\n    }\n\n    case 'status': {\n      logger.info({ msg: 'Checking migration status (prisma migrate status)…' });\n      const code = await runPrisma(['migrate', 'status']);\n      if (code !== 0) process.exit(code);\n      break;\n    }\n\n    case 'generate': {\n      logger.info({ msg: 'Generating Prisma client (prisma generate)…' });\n      const code = await runPrisma(['generate']);\n      if (code !== 0) process.exit(code);\n      logger.info({ msg: 'Prisma client generated.' });\n      break;\n    }\n\n    case 'reset': {\n      forbidInProdUnlessForced(cmd);\n      logger.warn({\n        msg: 'RESETTING DATABASE (prisma migrate reset)… This WILL DROP all data.',\n        FORCE,\n      });\n      const args = ['migrate', 'reset', '--force'];\n      // Allow running seed after reset if you want: remove --skip-seed to enable seeding script\n      if (process.env.SKIP_SEED === '1') args.push('--skip-seed');\n      const code = await runPrisma(args);\n      if (code !== 0) process.exit(code);\n      logger.info({ msg: 'Database reset complete.' });\n      break;\n    }\n\n    case 'push': {\n      forbidInProdUnlessForced(cmd);\n      logger.warn({\n        msg: 'Applying schema changes with prisma db push (DEV ONLY). Prefer migrations for prod.',\n        FORCE,\n      });\n      const code = await runPrisma(['db', 'push']);\n      if (code !== 0) process.exit(code);\n      logger.info({ msg: 'db push completed.' });\n      break;\n    }\n\n    default: {\n      const msg =\n        `Unknown command: ${rawCmd}\\n` +\n        `Usage: ts-node src/migrate.ts <deploy|status|generate|reset|push>`;\n      logger.error({ msg, rawCmd });\n      process.stderr.write(`${msg}\\n`);\n      process.exit(1);\n    }\n  }\n}\n\nmain().catch((err) => {\n  logger.error({ msg: 'Migration runner crashed', err });\n  process.stderr.write(`Migration error: ${(err as Error).message}\\n`);\n  process.exit(1);\n});","usedDeprecatedRules":[]},{"filePath":"/Users/azaatar/bowdoin-marketplace/packages/db/src/seed.ts","messages":[{"ruleId":"import/order","severity":2,"message":"There should be at least one empty line between import groups","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":47,"fix":{"range":[208,208],"text":"\n"}},{"ruleId":"import/order","severity":2,"message":"`@prisma/client` import should occur after import of `@bowdoin/observability/logger`","line":8,"column":1,"nodeType":"ImportDeclaration","endLine":8,"endColumn":47,"fix":{"range":[162,306],"text":"import { randomUUID } from 'crypto';\nimport { logger } from '@bowdoin/observability/logger';\nimport { PrismaClient } from '@prisma/client';\n"}},{"ruleId":"import/order","severity":2,"message":"There should be at least one empty line between import groups","line":9,"column":1,"nodeType":"ImportDeclaration","endLine":9,"endColumn":37,"fix":{"range":[245,245],"text":"\n"}},{"ruleId":"import/no-unresolved","severity":2,"message":"Unable to resolve path to module '@bowdoin/observability/logger'.","line":10,"column":24,"nodeType":"Literal","endLine":10,"endColumn":59},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":94,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":94,"endColumn":12},{"ruleId":"@typescript-eslint/no-misused-promises","severity":2,"message":"Promise returned in function argument where a void return was expected.","line":96,"column":12,"nodeType":"ArrowFunctionExpression","messageId":"voidReturnArgument","endLine":98,"endColumn":4}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":3,"fixableWarningCount":0,"source":"/**\n * Bowdoin Marketplace — Database Seed Script\n *\n * Seeds development data into the database.\n * Safe to run multiple times (idempotent where possible).\n */\n\nimport { PrismaClient } from '@prisma/client';\nimport { randomUUID } from 'crypto';\nimport { logger } from '@bowdoin/observability/logger';\n\nconst prisma = new PrismaClient();\n\nasync function seed() {\n  logger.info('🌱 Starting database seeding...');\n\n  // ---------------------------------------------------------------------------\n  // Example Users\n  // ---------------------------------------------------------------------------\n\n  const adminEmail = 'admin@bowdoin.edu';\n  const communityEmail = 'dev@example.com';\n\n  const adminUser = await prisma.user.upsert({\n    where: { email: adminEmail },\n    update: {},\n    create: {\n      id: randomUUID(),\n      email: adminEmail,\n      name: 'Admin User',\n      role: 'ADMIN',\n      affiliation: 'CAMPUS',\n    },\n  });\n\n  const communityUser = await prisma.user.upsert({\n    where: { email: communityEmail },\n    update: {},\n    create: {\n      id: randomUUID(),\n      email: communityEmail,\n      name: 'Community Tester',\n      role: 'USER',\n      affiliation: 'COMMUNITY',\n      communityEmail,\n      communityVerifiedAt: new Date(),\n    },\n  });\n\n  logger.info(\n    { adminId: adminUser.id, communityId: communityUser.id },\n    '✅ Seeded users'\n  );\n\n  // ---------------------------------------------------------------------------\n  // Example Listings\n  // ---------------------------------------------------------------------------\n\n  await prisma.listing.createMany({\n    skipDuplicates: true,\n    data: [\n      {\n        id: randomUUID(),\n        title: 'Used Textbook - ECON101',\n        description: 'Like new, $30',\n        price: 30,\n        status: 'ACTIVE',\n        sellerId: adminUser.id,\n        audience: 'CAMPUS',\n      },\n      {\n        id: randomUUID(),\n        title: 'Free Couch',\n        description: 'Pickup in Brunswick',\n        price: 0,\n        status: 'ACTIVE',\n        sellerId: communityUser.id,\n        audience: 'COMMUNITY',\n      },\n    ],\n  });\n\n  logger.info('✅ Seeded listings');\n\n  // ---------------------------------------------------------------------------\n  // Done\n  // ---------------------------------------------------------------------------\n  logger.info('🌱 Database seeding completed successfully');\n}\n\nseed()\n  .catch((err) => {\n    logger.error(err, '❌ Database seeding failed');\n    process.exit(1);\n  })\n  .finally(async () => {\n    await prisma.$disconnect();\n  });","usedDeprecatedRules":[]}]