// packages/queue/src/jobs/imageProcessing.ts
/**
 * Image processing job contracts & helpers.
 *
 * Scope:
 * - Defines stable job names used by workers and producers.
 * - Zod-validated payloads (ensures all producers enqueue consistent data).
 * - Sensible defaults for marketplace listing images.
 * - Pure “planning” utilities (deriving variant destination keys, etc.).
 *
 * NOTE: the actual pixel work (Sharp transforms, S3 I/O) is implemented
 * in the image worker (`packages/queue/src/workers/imageWorker.ts`) so this
 * module stays side-effect free and easy to unit test.
 */

import { randomUUID } from 'node:crypto';
import { posix as path } from 'node:path';

import { z } from 'zod';

/** Job names (keep stable to avoid dangling metrics/dashboards) */
export const ImageJobNames = {
  PROCESS_ORIGINAL: 'image.process', // process an original and emit variants
  CLEANUP_ORPHANS: 'image.cleanup', // (optional) remove orphaned variants by prefix
} as const;
export type ImageJobName = (typeof ImageJobNames)[keyof typeof ImageJobNames];

/** Supported output formats for generated variants (tuned for web delivery) */
export const OutputFormats = ['avif', 'webp', 'jpeg'] as const;
export type OutputFormat = (typeof OutputFormats)[number];

/** Sharp-like fit modes we intend to support */
export const ObjectFit = ['cover', 'contain', 'fill', 'inside', 'outside'] as const;
export type ObjectFitMode = (typeof ObjectFit)[number];

/** Minimal set of image MIME types we’ll accept for originals */
export const SupportedOriginalMimes = [
  'image/jpeg',
  'image/png',
  'image/webp',
  'image/avif',
  'image/heic',
] as const;
export type SupportedOriginalMime = (typeof SupportedOriginalMimes)[number];

/** A single variant transform request */
export const VariantSchema = z.object({
  /** Short, URL-safe name of the variant (e.g., "sm", "md", "lg@2x"). */
  name: z.string().min(1).max(32).regex(/^[a-z0-9@x-]+$/),
  /** Target width in pixels (height is optional; if omitted, maintain aspect ratio). */
  width: z.number().int().positive(),
  /** Optional target height; when omitted, height is auto with respect to `fit`. */
  height: z.number().int().positive().optional(),
  /** Fit strategy (default cover). */
  fit: z.enum(ObjectFit).default('cover'),
  /** Output format (default webp for broad support/perf). */
  format: z.enum(OutputFormats).default('webp'),
  /** Quality (1..100), reasonable defaults per format will be applied by worker if omitted. */
  quality: z.number().int().min(1).max(100).default(80),
  /** Do not upscale smaller images (default true). */
  withoutEnlargement: z.boolean().default(true),
  /** Progressive encoding (relevant for JPEG). */
  progressive: z.boolean().default(false),
});
export type Variant = z.infer<typeof VariantSchema>;

export const ProcessImagePayloadSchema = z.object({
  /** Correlates variants to a specific listing entity. */
  listingId: z.string().uuid(),
  /** Uploader user id (for audit). */
  uploaderUserId: z.string().uuid(),
  /** Source bucket/key of the uploaded original image. */
  bucket: z.string().min(3),
  keyOriginal: z.string().min(3),
  /** Optional content-type of the original (helps validation). */
  originalContentType: z.enum(SupportedOriginalMimes).optional(),
  /**
   * Where to write derived files, as a bucket prefix (e.g., `listings/{listingId}/images/`).
   * You may pass '' to use the directory of `keyOriginal`.
   */
  outputPrefix: z.string().default(''),
  /** Strip EXIF/metadata on all outputs (default true). */
  stripExif: z.boolean().default(true),
  /** Overwrite existing variant keys if present (default false). */
  overwrite: z.boolean().default(false),
  /** One or more variant transforms to generate. */
  variants: z.array(VariantSchema).min(1),
  /** Optional request metadata for audit/observability. */
  audit: z
    .object({
      requestId: z.string().optional(),
      source: z.string().optional(), // e.g., 'api/upload/presign'
    })
    .optional(),
  /** Optional idempotency key; if omitted a UUID will be generated by the producer. */
  idempotencyKey: z.string().optional(),
});
export type ProcessImagePayload = z.infer<typeof ProcessImagePayloadSchema>;

/** Cleanup job payload (remove keys by prefix). */
export const CleanupPayloadSchema = z.object({
  bucket: z.string().min(3),
  /** A safe prefix (e.g., `listings/{listingId}/images/abc123/`). */
  prefix: z.string().min(1),
  /** Dry run = list only; worker logs the would-delete set. */
  dryRun: z.boolean().default(true),
});
export type CleanupPayload = z.infer<typeof CleanupPayloadSchema>;

/**
 * Recommended variant set for listing images.
 * - `sm` (thumbnail), `md` (card), `lg` (detail), each in AVIF+WebP.
 * You can override/extend per enqueue.
 */
export function defaultListingVariants(): Variant[] {
  const sizes = [
    { name: 'sm', width: 320 },
    { name: 'md', width: 640 },
    { name: 'lg', width: 1280 },
  ] as const;

  const formats: OutputFormat[] = ['avif', 'webp'];

  const variants: Variant[] = [];
  for (const s of sizes) {
    for (const f of formats) {
      variants.push({
        name: s.name,
        width: s.width,
        format: f,
        fit: 'cover',
        withoutEnlargement: true,
        quality: f === 'avif' ? 55 : 75,
        progressive: f === 'jpeg', // no-op for avif/webp
      });
    }
  }
  return variants;
}

/** Utility: derive destination object key for a variant */
export function deriveVariantKey(params: {
  keyOriginal: string;
  outputPrefix?: string;
  variantName: string;
  format: OutputFormat;
}): string {
  const { keyOriginal, outputPrefix = '', variantName, format } = params;

  const parsed = path.parse(keyOriginal);
  // Directory to place outputs:
  // - If outputPrefix provided -> join(prefix, baseName)
  // - Else -> reuse the original directory.
  const baseName = parsed.name; // original name without extension
  const dir = outputPrefix ? outputPrefix.replace(/^\/+/, '') : parsed.dir; // ensure no leading slash

  // e.g., listings/uuid/images/myfile.sm.avif
  return path.join(dir, `${baseName}.${variantName}.${format}`);
}

/** Helper: lenient original MIME validation (falls back to extension if mime missing) */
export function isProbablySupportedOriginal({
  contentType,
  keyOriginal,
}: {
  contentType?: string;
  keyOriginal: string;
}): boolean {
  if (contentType && (SupportedOriginalMimes as readonly string[]).includes(contentType)) {
    return true;
  }
  const ext = path.extname(keyOriginal).toLowerCase().replace(/^\./, '');
  // Common extensions we allow to pass through to Sharp
  return ['jpg', 'jpeg', 'png', 'webp', 'avif', 'heic'].includes(ext);
}

/** Plan out the output keys for each variant (pure, side-effect free) */
export function planVariantOutputs(payload: ProcessImagePayload) {
  const variants = payload.variants.map((v) => ({
    ...v,
    destKey: deriveVariantKey({
      keyOriginal: payload.keyOriginal,
      outputPrefix: payload.outputPrefix,
      variantName: v.name,
      format: v.format,
    }),
  }));
  return { ...payload, variants };
}

export type PlannedProcessImagePayload = ReturnType<typeof planVariantOutputs>;

/**
 * High-level convenience for callers:
 * Build a validated, defaulted PROCESS_ORIGINAL payload for a listing image.
 * This does not enqueue; use the queue package helpers (`enqueueImageJob`) to add it.
 */
export function buildListingImageProcessPayload(input: {
  listingId: string;
  uploaderUserId: string;
  bucket: string;
  keyOriginal: string;
  outputPrefix?: string; // e.g., `listings/${listingId}/images/`
  originalContentType?: SupportedOriginalMime;
  variants?: Variant[];
  stripExif?: boolean;
  overwrite?: boolean;
  audit?: { requestId?: string; source?: string };
  idempotencyKey?: string;
}): PlannedProcessImagePayload {
  const payload = ProcessImagePayloadSchema.parse({
    ...input,
    variants: input.variants ?? defaultListingVariants(),
    idempotencyKey: input.idempotencyKey ?? randomUUID(),
  });

  const supportCheck = {
    keyOriginal: payload.keyOriginal,
    ...(payload.originalContentType ? { contentType: payload.originalContentType } : {}),
  } as const;

  if (!isProbablySupportedOriginal(supportCheck)) {
    throw new Error(
      `Unsupported original image type for key=${payload.keyOriginal} contentType=${payload.originalContentType ?? 'unknown'}`,
    );
  }

  return planVariantOutputs(payload);
}

/**
 * Factory for a BullMQ-compatible job descriptor.
 * Example:
 *   const job = createProcessImageJob(buildListingImageProcessPayload({...}));
 *   await queue.add(job.name, job.data, job.opts);
 */
export function createProcessImageJob(
  planned: PlannedProcessImagePayload,
  opts?: {
    priority?: number;
    delayMs?: number;
    jobId?: string; // if omitted BullMQ will generate
    attempts?: number;
  },
) {
  return {
    name: ImageJobNames.PROCESS_ORIGINAL,
    data: planned,
    opts: {
      jobId: opts?.jobId,
      priority: opts?.priority ?? 2, // 1 = highest, 2 = normal for us
      delay: opts?.delayMs ?? 0,
      attempts: opts?.attempts ?? 3,
      removeOnComplete: { age: 60 * 60, count: 1000 },
      removeOnFail: { age: 24 * 60 * 60, count: 1000 },
    } as const,
  };
}

/**
 * Cleanup helpers – useful if a listing image was removed or replaced.
 */
export function buildCleanupJob(input: z.input<typeof CleanupPayloadSchema>) {
  const payload = CleanupPayloadSchema.parse(input);
  return {
    name: ImageJobNames.CLEANUP_ORPHANS,
    data: payload,
    opts: {
      priority: 5, // background
      attempts: 1,
      removeOnComplete: { age: 10 * 60, count: 100 },
      removeOnFail: { age: 60 * 60, count: 100 },
    } as const,
  };
}

/** Types re-export for consumers */
export type { PlannedProcessImagePayload as ImageProcessPlanned };
